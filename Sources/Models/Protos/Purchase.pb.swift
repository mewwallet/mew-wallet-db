// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Purchase.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct PurchaseHistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var results: [TransactionIdPB] = []

  var paginationToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PurchaseProvidersPlatformAndISOResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var web: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct QuoteAndOrderForPurchasingETHViaSimplexResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var form: FormPB {
    get {return _form ?? FormPB()}
    set {_form = newValue}
  }
  /// Returns true if `form` has been explicitly set.
  var hasForm: Bool {return self._form != nil}
  /// Clears the value of `form`. Subsequent reads from it will return its default value.
  mutating func clearForm() {self._form = nil}

  var formEncoded: String = String()

  var contentLength: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _form: FormPB? = nil
}

struct PurchasProvidersAndLimitsAndISOResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var providers: [ProviderPB] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ProviderPB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var fiatCurrencies: [String] = []

  var cryptoCurrencies: [String] = []

  var ach: Bool = false

  var prices: [PricePB] = []

  var limits: [LimitPB] = []

  var conversionRates: [RatePB] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PricePB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fiatCurrency: String = String()

  var cryptoCurrency: String = String()

  var price: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LimitPB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var fiatCurrency: String = String()

  var limit: LimitInternalPB {
    get {return _limit ?? LimitInternalPB()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {self._limit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _limit: LimitInternalPB? = nil
}

struct LimitInternalPB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var min: String = String()

  var max: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RatePB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fiatCurrency: String = String()

  var exchangeRate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FormPB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String = String()

  var paymentFlowType: String = String()

  var returnURL: String = String()

  var quoteID: String = String()

  var paymentID: String = String()

  var userID: String = String()

  var destinationWalletAddress: String = String()

  var destinationWalletCurrency: String = String()

  var fiatTotalAmountAmount: String = String()

  var fiatTotalAmountCurrency: String = String()

  var digitalTotalAmountAmount: Int32 = 0

  var digitalTotalAmountCurrency: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TransactionIdPB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String = String()

  var fiatAmount: String = String()

  var fiatCurrency: String = String()

  var cryptoAmount: String = String()

  var timestamp: String = String()

  var status: String = String()

  var provider: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PurchaseHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PurchaseHistoryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    2: .standard(proto: "pagination_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.paginationToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if !self.paginationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.paginationToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PurchaseHistoryResponse, rhs: PurchaseHistoryResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.paginationToken != rhs.paginationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PurchaseProvidersPlatformAndISOResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PurchaseProvidersPlatformAndISOResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "web"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.web) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.web.isEmpty {
      try visitor.visitSingularStringField(value: self.web, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PurchaseProvidersPlatformAndISOResponse, rhs: PurchaseProvidersPlatformAndISOResponse) -> Bool {
    if lhs.web != rhs.web {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QuoteAndOrderForPurchasingETHViaSimplexResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "QuoteAndOrderForPurchasingETHViaSimplexResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "form"),
    3: .standard(proto: "form_encoded"),
    4: .standard(proto: "content_length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._form) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.formEncoded) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.contentLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try { if let v = self._form {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.formEncoded.isEmpty {
      try visitor.visitSingularStringField(value: self.formEncoded, fieldNumber: 3)
    }
    if self.contentLength != 0 {
      try visitor.visitSingularInt32Field(value: self.contentLength, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QuoteAndOrderForPurchasingETHViaSimplexResponse, rhs: QuoteAndOrderForPurchasingETHViaSimplexResponse) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs._form != rhs._form {return false}
    if lhs.formEncoded != rhs.formEncoded {return false}
    if lhs.contentLength != rhs.contentLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PurchasProvidersAndLimitsAndISOResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PurchasProvidersAndLimitsAndISOResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "providers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.providers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.providers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.providers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PurchasProvidersAndLimitsAndISOResponse, rhs: PurchasProvidersAndLimitsAndISOResponse) -> Bool {
    if lhs.providers != rhs.providers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProviderPB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProviderPB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "fiat_currencies"),
    3: .standard(proto: "crypto_currencies"),
    4: .same(proto: "ach"),
    5: .same(proto: "prices"),
    6: .same(proto: "limits"),
    7: .standard(proto: "conversion_rates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.fiatCurrencies) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.cryptoCurrencies) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.ach) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.prices) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.limits) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.conversionRates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.fiatCurrencies.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fiatCurrencies, fieldNumber: 2)
    }
    if !self.cryptoCurrencies.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cryptoCurrencies, fieldNumber: 3)
    }
    if self.ach != false {
      try visitor.visitSingularBoolField(value: self.ach, fieldNumber: 4)
    }
    if !self.prices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prices, fieldNumber: 5)
    }
    if !self.limits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.limits, fieldNumber: 6)
    }
    if !self.conversionRates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conversionRates, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProviderPB, rhs: ProviderPB) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.fiatCurrencies != rhs.fiatCurrencies {return false}
    if lhs.cryptoCurrencies != rhs.cryptoCurrencies {return false}
    if lhs.ach != rhs.ach {return false}
    if lhs.prices != rhs.prices {return false}
    if lhs.limits != rhs.limits {return false}
    if lhs.conversionRates != rhs.conversionRates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PricePB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PricePB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fiat_currency"),
    2: .standard(proto: "crypto_currency"),
    3: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fiatCurrency) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cryptoCurrency) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fiatCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.fiatCurrency, fieldNumber: 1)
    }
    if !self.cryptoCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.cryptoCurrency, fieldNumber: 2)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PricePB, rhs: PricePB) -> Bool {
    if lhs.fiatCurrency != rhs.fiatCurrency {return false}
    if lhs.cryptoCurrency != rhs.cryptoCurrency {return false}
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LimitPB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LimitPB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "fiat_currency"),
    3: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fiatCurrency) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.fiatCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.fiatCurrency, fieldNumber: 2)
    }
    try { if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LimitPB, rhs: LimitPB) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.fiatCurrency != rhs.fiatCurrency {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LimitInternalPB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LimitInternalPB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.min) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.max) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.min.isEmpty {
      try visitor.visitSingularStringField(value: self.min, fieldNumber: 1)
    }
    if !self.max.isEmpty {
      try visitor.visitSingularStringField(value: self.max, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LimitInternalPB, rhs: LimitInternalPB) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RatePB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RatePB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fiat_currency"),
    2: .standard(proto: "exchange_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fiatCurrency) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exchangeRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fiatCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.fiatCurrency, fieldNumber: 1)
    }
    if !self.exchangeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeRate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RatePB, rhs: RatePB) -> Bool {
    if lhs.fiatCurrency != rhs.fiatCurrency {return false}
    if lhs.exchangeRate != rhs.exchangeRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FormPB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FormPB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "payment_flow_type"),
    3: .standard(proto: "return_url"),
    4: .standard(proto: "quote_id"),
    5: .standard(proto: "payment_id"),
    6: .standard(proto: "user_id"),
    7: .standard(proto: "destination_wallet_address"),
    8: .standard(proto: "destination_wallet_currency"),
    9: .standard(proto: "fiat_total_amount_amount"),
    10: .standard(proto: "fiat_total_amount_currency"),
    11: .standard(proto: "digital_total_amount_amount"),
    12: .standard(proto: "digital_total_amount_currency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.paymentFlowType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.returnURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quoteID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.paymentID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.destinationWalletAddress) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.destinationWalletCurrency) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.fiatTotalAmountAmount) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.fiatTotalAmountCurrency) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.digitalTotalAmountAmount) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.digitalTotalAmountCurrency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.paymentFlowType.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentFlowType, fieldNumber: 2)
    }
    if !self.returnURL.isEmpty {
      try visitor.visitSingularStringField(value: self.returnURL, fieldNumber: 3)
    }
    if !self.quoteID.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteID, fieldNumber: 4)
    }
    if !self.paymentID.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentID, fieldNumber: 5)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 6)
    }
    if !self.destinationWalletAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationWalletAddress, fieldNumber: 7)
    }
    if !self.destinationWalletCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationWalletCurrency, fieldNumber: 8)
    }
    if !self.fiatTotalAmountAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.fiatTotalAmountAmount, fieldNumber: 9)
    }
    if !self.fiatTotalAmountCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.fiatTotalAmountCurrency, fieldNumber: 10)
    }
    if self.digitalTotalAmountAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.digitalTotalAmountAmount, fieldNumber: 11)
    }
    if !self.digitalTotalAmountCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.digitalTotalAmountCurrency, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FormPB, rhs: FormPB) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.paymentFlowType != rhs.paymentFlowType {return false}
    if lhs.returnURL != rhs.returnURL {return false}
    if lhs.quoteID != rhs.quoteID {return false}
    if lhs.paymentID != rhs.paymentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.destinationWalletAddress != rhs.destinationWalletAddress {return false}
    if lhs.destinationWalletCurrency != rhs.destinationWalletCurrency {return false}
    if lhs.fiatTotalAmountAmount != rhs.fiatTotalAmountAmount {return false}
    if lhs.fiatTotalAmountCurrency != rhs.fiatTotalAmountCurrency {return false}
    if lhs.digitalTotalAmountAmount != rhs.digitalTotalAmountAmount {return false}
    if lhs.digitalTotalAmountCurrency != rhs.digitalTotalAmountCurrency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TransactionIdPB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TransactionIdPB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .standard(proto: "fiat_amount"),
    3: .standard(proto: "fiat_currency"),
    4: .standard(proto: "crypto_amount"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "status"),
    7: .same(proto: "provider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fiatAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fiatCurrency) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cryptoAmount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if !self.fiatAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.fiatAmount, fieldNumber: 2)
    }
    if !self.fiatCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.fiatCurrency, fieldNumber: 3)
    }
    if !self.cryptoAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.cryptoAmount, fieldNumber: 4)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 5)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 6)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TransactionIdPB, rhs: TransactionIdPB) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.fiatAmount != rhs.fiatAmount {return false}
    if lhs.fiatCurrency != rhs.fiatCurrency {return false}
    if lhs.cryptoAmount != rhs.cryptoAmount {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.status != rhs.status {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
