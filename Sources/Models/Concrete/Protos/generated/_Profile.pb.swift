// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: _Profile.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct _Profile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var settings: _Profile._Settings {
    get {return _settings ?? _Profile._Settings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  mutating func clearSettings() {self._settings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct _Settings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var addresses: [_Profile._Settings._Address] = []

    var timezone: String = String()

    var portfolioTracker: _Profile._Settings._PortfolioTracker {
      get {return _portfolioTracker ?? _Profile._Settings._PortfolioTracker()}
      set {_portfolioTracker = newValue}
    }
    /// Returns true if `portfolioTracker` has been explicitly set.
    var hasPortfolioTracker: Bool {return self._portfolioTracker != nil}
    /// Clears the value of `portfolioTracker`. Subsequent reads from it will return its default value.
    mutating func clearPortfolioTracker() {self._portfolioTracker = nil}

    var priceAlerts: [_Profile._Settings._PriceAlert] = []

    var gmtOffset: Int64 = 0

    var pushToken: String = String()

    var platform: String = String()

    var notifications: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum _Notifications: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case disabled // = 0
      case outgoingTx // = 1
      case incomingTx // = 2
      case announcements // = 4
      case sercurity // = 8
      case UNRECOGNIZED(Int)

      init() {
        self = .disabled
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .disabled
        case 1: self = .outgoingTx
        case 2: self = .incomingTx
        case 4: self = .announcements
        case 8: self = .sercurity
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .disabled: return 0
        case .outgoingTx: return 1
        case .incomingTx: return 2
        case .announcements: return 4
        case .sercurity: return 8
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Address
    struct _Address {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var address: String = String()

      var flags: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum _AddressFlags: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case disabled // = 0
        case includeInWeeklyPortfolioTracker // = 1
        case includeInDailyPortfolioTracker // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .disabled
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .disabled
          case 1: self = .includeInWeeklyPortfolioTracker
          case 3: self = .includeInDailyPortfolioTracker
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .disabled: return 0
          case .includeInWeeklyPortfolioTracker: return 1
          case .includeInDailyPortfolioTracker: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}
    }

    struct _PortfolioTracker {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var weekly: _Profile._Settings._PortfolioTracker._TrackerTime {
        get {return _weekly ?? _Profile._Settings._PortfolioTracker._TrackerTime()}
        set {_weekly = newValue}
      }
      /// Returns true if `weekly` has been explicitly set.
      var hasWeekly: Bool {return self._weekly != nil}
      /// Clears the value of `weekly`. Subsequent reads from it will return its default value.
      mutating func clearWeekly() {self._weekly = nil}

      var daily: _Profile._Settings._PortfolioTracker._TrackerTime {
        get {return _daily ?? _Profile._Settings._PortfolioTracker._TrackerTime()}
        set {_daily = newValue}
      }
      /// Returns true if `daily` has been explicitly set.
      var hasDaily: Bool {return self._daily != nil}
      /// Clears the value of `daily`. Subsequent reads from it will return its default value.
      mutating func clearDaily() {self._daily = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct _TrackerTime {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var enabled: Bool = false

        var timestamp: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}

      fileprivate var _weekly: _Profile._Settings._PortfolioTracker._TrackerTime? = nil
      fileprivate var _daily: _Profile._Settings._PortfolioTracker._TrackerTime? = nil
    }

    struct _PriceAlert {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var id: String = String()

      var trigger: String = String()

      var contractAddress: String = String()

      var type: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _portfolioTracker: _Profile._Settings._PortfolioTracker? = nil
  }

  init() {}

  fileprivate var _settings: _Profile._Settings? = nil
}

#if swift(>=4.2)

extension _Profile._Settings._Notifications: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [_Profile._Settings._Notifications] = [
    .disabled,
    .outgoingTx,
    .incomingTx,
    .announcements,
    .sercurity,
  ]
}

extension _Profile._Settings._Address._AddressFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [_Profile._Settings._Address._AddressFlags] = [
    .disabled,
    .includeInWeeklyPortfolioTracker,
    .includeInDailyPortfolioTracker,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension _Profile: @unchecked Sendable {}
extension _Profile._Settings: @unchecked Sendable {}
extension _Profile._Settings._Notifications: @unchecked Sendable {}
extension _Profile._Settings._Address: @unchecked Sendable {}
extension _Profile._Settings._Address._AddressFlags: @unchecked Sendable {}
extension _Profile._Settings._PortfolioTracker: @unchecked Sendable {}
extension _Profile._Settings._PortfolioTracker._TrackerTime: @unchecked Sendable {}
extension _Profile._Settings._PriceAlert: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension _Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "_Profile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _Profile, rhs: _Profile) -> Bool {
    if lhs._settings != rhs._settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _Profile._Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _Profile.protoMessageName + "._Settings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresses"),
    2: .same(proto: "timezone"),
    3: .standard(proto: "portfolio_tracker"),
    4: .standard(proto: "price_alerts"),
    5: .standard(proto: "gmt_offset"),
    6: .standard(proto: "push_token"),
    7: .same(proto: "platform"),
    8: .same(proto: "notifications"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.timezone) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._portfolioTracker) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.priceAlerts) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.gmtOffset) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.pushToken) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.notifications) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 1)
    }
    if !self.timezone.isEmpty {
      try visitor.visitSingularStringField(value: self.timezone, fieldNumber: 2)
    }
    try { if let v = self._portfolioTracker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.priceAlerts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.priceAlerts, fieldNumber: 4)
    }
    if self.gmtOffset != 0 {
      try visitor.visitSingularInt64Field(value: self.gmtOffset, fieldNumber: 5)
    }
    if !self.pushToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pushToken, fieldNumber: 6)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 7)
    }
    if self.notifications != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifications, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _Profile._Settings, rhs: _Profile._Settings) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.timezone != rhs.timezone {return false}
    if lhs._portfolioTracker != rhs._portfolioTracker {return false}
    if lhs.priceAlerts != rhs.priceAlerts {return false}
    if lhs.gmtOffset != rhs.gmtOffset {return false}
    if lhs.pushToken != rhs.pushToken {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.notifications != rhs.notifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _Profile._Settings._Notifications: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISABLED"),
    1: .same(proto: "OUTGOING_TX"),
    2: .same(proto: "INCOMING_TX"),
    4: .same(proto: "ANNOUNCEMENTS"),
    8: .same(proto: "SERCURITY"),
  ]
}

extension _Profile._Settings._Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _Profile._Settings.protoMessageName + "._Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "flags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _Profile._Settings._Address, rhs: _Profile._Settings._Address) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _Profile._Settings._Address._AddressFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISABLED"),
    1: .same(proto: "INCLUDE_IN_WEEKLY_PORTFOLIO_TRACKER"),
    3: .same(proto: "INCLUDE_IN_DAILY_PORTFOLIO_TRACKER"),
  ]
}

extension _Profile._Settings._PortfolioTracker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _Profile._Settings.protoMessageName + "._PortfolioTracker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "weekly"),
    2: .same(proto: "daily"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._weekly) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._daily) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._weekly {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._daily {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _Profile._Settings._PortfolioTracker, rhs: _Profile._Settings._PortfolioTracker) -> Bool {
    if lhs._weekly != rhs._weekly {return false}
    if lhs._daily != rhs._daily {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _Profile._Settings._PortfolioTracker._TrackerTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _Profile._Settings._PortfolioTracker.protoMessageName + "._TrackerTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _Profile._Settings._PortfolioTracker._TrackerTime, rhs: _Profile._Settings._PortfolioTracker._TrackerTime) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _Profile._Settings._PriceAlert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _Profile._Settings.protoMessageName + "._PriceAlert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "trigger"),
    3: .standard(proto: "contract_address"),
    4: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.trigger) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.trigger.isEmpty {
      try visitor.visitSingularStringField(value: self.trigger, fieldNumber: 2)
    }
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 3)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _Profile._Settings._PriceAlert, rhs: _Profile._Settings._PriceAlert) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.trigger != rhs.trigger {return false}
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
