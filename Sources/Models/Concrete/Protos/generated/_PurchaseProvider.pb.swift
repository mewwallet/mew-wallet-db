// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: _PurchaseProvider.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct _PurchaseProvider: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the provider
  var provider: String = String()

  var isos: [_PurchaseProvider._ISO] = []

  var fiats: [_PurchaseProvider._Fiat] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// List of ISOs with information about availability
  struct _ISO: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var allowed: _PurchaseProvider._ISO._Allowed {
      get {return _allowed ?? _PurchaseProvider._ISO._Allowed()}
      set {_allowed = newValue}
    }
    /// Returns true if `allowed` has been explicitly set.
    var hasAllowed: Bool {return self._allowed != nil}
    /// Clears the value of `allowed`. Subsequent reads from it will return its default value.
    mutating func clearAllowed() {self._allowed = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Represents availability of buy and sell
    struct _Allowed: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var buy: Bool = false

      var sell: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _allowed: _PurchaseProvider._ISO._Allowed? = nil
  }

  /// Detailed information about specific fiats
  struct _Fiat: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fiatCurrency: String = String()

    var limits: _PurchaseProvider._Fiat._Limits {
      get {return _limits ?? _PurchaseProvider._Fiat._Limits()}
      set {_limits = newValue}
    }
    /// Returns true if `limits` has been explicitly set.
    var hasLimits: Bool {return self._limits != nil}
    /// Clears the value of `limits`. Subsequent reads from it will return its default value.
    mutating func clearLimits() {self._limits = nil}

    var paymentMethods: [String] = []

    var isSellSupported: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct _Limits: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var min: Double = 0

      var max: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _limits: _PurchaseProvider._Fiat._Limits? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension _PurchaseProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "_PurchaseProvider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "isos"),
    3: .same(proto: "fiats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.isos) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fiats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 1)
    }
    if !self.isos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.isos, fieldNumber: 2)
    }
    if !self.fiats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fiats, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _PurchaseProvider, rhs: _PurchaseProvider) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.isos != rhs.isos {return false}
    if lhs.fiats != rhs.fiats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _PurchaseProvider._ISO: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _PurchaseProvider.protoMessageName + "._ISO"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allowed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._allowed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._allowed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _PurchaseProvider._ISO, rhs: _PurchaseProvider._ISO) -> Bool {
    if lhs._allowed != rhs._allowed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _PurchaseProvider._ISO._Allowed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _PurchaseProvider._ISO.protoMessageName + "._Allowed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "buy"),
    2: .same(proto: "sell"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.buy) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.sell) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.buy != false {
      try visitor.visitSingularBoolField(value: self.buy, fieldNumber: 1)
    }
    if self.sell != false {
      try visitor.visitSingularBoolField(value: self.sell, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _PurchaseProvider._ISO._Allowed, rhs: _PurchaseProvider._ISO._Allowed) -> Bool {
    if lhs.buy != rhs.buy {return false}
    if lhs.sell != rhs.sell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _PurchaseProvider._Fiat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _PurchaseProvider.protoMessageName + "._Fiat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fiat_currency"),
    2: .same(proto: "limits"),
    3: .standard(proto: "payment_methods"),
    4: .standard(proto: "is_sell_supported"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fiatCurrency) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._limits) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.paymentMethods) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSellSupported) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fiatCurrency.isEmpty {
      try visitor.visitSingularStringField(value: self.fiatCurrency, fieldNumber: 1)
    }
    try { if let v = self._limits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.paymentMethods.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paymentMethods, fieldNumber: 3)
    }
    if self.isSellSupported != false {
      try visitor.visitSingularBoolField(value: self.isSellSupported, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _PurchaseProvider._Fiat, rhs: _PurchaseProvider._Fiat) -> Bool {
    if lhs.fiatCurrency != rhs.fiatCurrency {return false}
    if lhs._limits != rhs._limits {return false}
    if lhs.paymentMethods != rhs.paymentMethods {return false}
    if lhs.isSellSupported != rhs.isSellSupported {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _PurchaseProvider._Fiat._Limits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _PurchaseProvider._Fiat.protoMessageName + "._Limits"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.min) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.max) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.min, fieldNumber: 1)
    }
    if self.max.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.max, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _PurchaseProvider._Fiat._Limits, rhs: _PurchaseProvider._Fiat._Limits) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
