// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: _EnergyRewardReceipt.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represent Historical Energy Reward record
struct _EnergyRewardReceipt: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var purchaseType: _EnergyRewardReceipt._PurchaseType {
    get {return _storage._purchaseType}
    set {_uniqueStorage()._purchaseType = newValue}
  }

  var rewardID: String {
    get {return _storage._rewardID}
    set {_uniqueStorage()._rewardID = newValue}
  }

  var item: _EnergyRewardReceipt._Item {
    get {return _storage._item ?? _EnergyRewardReceipt._Item()}
    set {_uniqueStorage()._item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  var hasItem: Bool {return _storage._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  mutating func clearItem() {_uniqueStorage()._item = nil}

  var isSpent: Bool {
    get {return _storage._isSpent}
    set {_uniqueStorage()._isSpent = newValue}
  }

  var purchaseDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._purchaseDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._purchaseDate = newValue}
  }
  /// Returns true if `purchaseDate` has been explicitly set.
  var hasPurchaseDate: Bool {return _storage._purchaseDate != nil}
  /// Clears the value of `purchaseDate`. Subsequent reads from it will return its default value.
  mutating func clearPurchaseDate() {_uniqueStorage()._purchaseDate = nil}

  var nftTx: _EnergyNFTTransfer {
    get {return _storage._nftTx ?? _EnergyNFTTransfer()}
    set {_uniqueStorage()._nftTx = newValue}
  }
  /// Returns true if `nftTx` has been explicitly set.
  var hasNftTx: Bool {return _storage._nftTx != nil}
  /// Clears the value of `nftTx`. Subsequent reads from it will return its default value.
  mutating func clearNftTx() {_uniqueStorage()._nftTx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum _PurchaseType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case consumable // = 1
    case nonconsumable // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .consumable
      case 2: self = .nonconsumable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .consumable: return 1
      case .nonconsumable: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [_EnergyRewardReceipt._PurchaseType] = [
      .unknown,
      .consumable,
      .nonconsumable,
    ]

  }

  struct _Item: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var itemID: String = String()

    var name: String = String()

    var description_p: String {
      get {return _description_p ?? String()}
      set {_description_p = newValue}
    }
    /// Returns true if `description_p` has been explicitly set.
    var hasDescription_p: Bool {return self._description_p != nil}
    /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
    mutating func clearDescription_p() {self._description_p = nil}

    var chance: String = String()

    var type: _EnergyRewardReceipt._Item._ItemType = .unknown

    var payload: _EnergyRewardReceipt._Item.OneOf_Payload? = nil

    var nft: _EnergyRewardReceipt._Item._NFT {
      get {
        if case .nft(let v)? = payload {return v}
        return _EnergyRewardReceipt._Item._NFT()
      }
      set {payload = .nft(newValue)}
    }

    var icon: _EnergyRewardReceipt._Item._ICON {
      get {
        if case .icon(let v)? = payload {return v}
        return _EnergyRewardReceipt._Item._ICON()
      }
      set {payload = .icon(newValue)}
    }

    var energy: _EnergyRewardReceipt._Item._ENERGY {
      get {
        if case .energy(let v)? = payload {return v}
        return _EnergyRewardReceipt._Item._ENERGY()
      }
      set {payload = .energy(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Payload: Equatable, Sendable {
      case nft(_EnergyRewardReceipt._Item._NFT)
      case icon(_EnergyRewardReceipt._Item._ICON)
      case energy(_EnergyRewardReceipt._Item._ENERGY)

    }

    enum _ItemType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case icon // = 1
      case energy // = 2
      case nft // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .icon
        case 2: self = .energy
        case 3: self = .nft
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .icon: return 1
        case .energy: return 2
        case .nft: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [_EnergyRewardReceipt._Item._ItemType] = [
        .unknown,
        .icon,
        .energy,
        .nft,
      ]

    }

    struct _NFT: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var url: String = String()

      var rarity: _EnergyRewardReceipt._Item._NFT._Rarity = .unknown

      var tokenID: Int64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum _Rarity: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case common // = 1
        case uncommon // = 2
        case rare // = 3
        case epic // = 4
        case legendary // = 5
        case exclusive // = 6
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .common
          case 2: self = .uncommon
          case 3: self = .rare
          case 4: self = .epic
          case 5: self = .legendary
          case 6: self = .exclusive
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .common: return 1
          case .uncommon: return 2
          case .rare: return 3
          case .epic: return 4
          case .legendary: return 5
          case .exclusive: return 6
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [_EnergyRewardReceipt._Item._NFT._Rarity] = [
          .unknown,
          .common,
          .uncommon,
          .rare,
          .epic,
          .legendary,
          .exclusive,
        ]

      }

      init() {}
    }

    struct _ICON: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var id: _EnergyRewardReceipt._Item._ICON._IconID = .iconUnknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum _IconID: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case iconUnknown // = 0
        case iconEnergy // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .iconUnknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .iconUnknown
          case 1: self = .iconEnergy
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .iconUnknown: return 0
          case .iconEnergy: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [_EnergyRewardReceipt._Item._ICON._IconID] = [
          .iconUnknown,
          .iconEnergy,
        ]

      }

      init() {}
    }

    struct _ENERGY: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var url: String = String()

      var amount: String = String()

      var size: _EnergyRewardReceipt._Item._ENERGY._Size = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum _Size: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case small // = 1
        case medium // = 2
        case large // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .small
          case 2: self = .medium
          case 3: self = .large
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .small: return 1
          case .medium: return 2
          case .large: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [_EnergyRewardReceipt._Item._ENERGY._Size] = [
          .unknown,
          .small,
          .medium,
          .large,
        ]

      }

      init() {}
    }

    init() {}

    fileprivate var _description_p: String? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension _EnergyRewardReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "_EnergyRewardReceipt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "purchase_type"),
    3: .standard(proto: "reward_id"),
    4: .same(proto: "item"),
    5: .standard(proto: "is_spent"),
    6: .standard(proto: "purchase_date"),
    7: .standard(proto: "nft_tx"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String = String()
    var _purchaseType: _EnergyRewardReceipt._PurchaseType = .unknown
    var _rewardID: String = String()
    var _item: _EnergyRewardReceipt._Item? = nil
    var _isSpent: Bool = false
    var _purchaseDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _nftTx: _EnergyNFTTransfer? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _purchaseType = source._purchaseType
      _rewardID = source._rewardID
      _item = source._item
      _isSpent = source._isSpent
      _purchaseDate = source._purchaseDate
      _nftTx = source._nftTx
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._purchaseType) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._rewardID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._item) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isSpent) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._purchaseDate) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._nftTx) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 1)
      }
      if _storage._purchaseType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._purchaseType, fieldNumber: 2)
      }
      if !_storage._rewardID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rewardID, fieldNumber: 3)
      }
      try { if let v = _storage._item {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._isSpent != false {
        try visitor.visitSingularBoolField(value: _storage._isSpent, fieldNumber: 5)
      }
      try { if let v = _storage._purchaseDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._nftTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _EnergyRewardReceipt, rhs: _EnergyRewardReceipt) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._purchaseType != rhs_storage._purchaseType {return false}
        if _storage._rewardID != rhs_storage._rewardID {return false}
        if _storage._item != rhs_storage._item {return false}
        if _storage._isSpent != rhs_storage._isSpent {return false}
        if _storage._purchaseDate != rhs_storage._purchaseDate {return false}
        if _storage._nftTx != rhs_storage._nftTx {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _EnergyRewardReceipt._PurchaseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "_PURCHASETYPE_UNKNOWN"),
    1: .same(proto: "_PURCHASETYPE_CONSUMABLE"),
    2: .same(proto: "_PURCHASETYPE_NONCONSUMABLE"),
  ]
}

extension _EnergyRewardReceipt._Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _EnergyRewardReceipt.protoMessageName + "._Item"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "chance"),
    5: .same(proto: "type"),
    6: .same(proto: "nft"),
    7: .same(proto: "icon"),
    8: .same(proto: "energy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.itemID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.chance) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 6: try {
        var v: _EnergyRewardReceipt._Item._NFT?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .nft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .nft(v)
        }
      }()
      case 7: try {
        var v: _EnergyRewardReceipt._Item._ICON?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .icon(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .icon(v)
        }
      }()
      case 8: try {
        var v: _EnergyRewardReceipt._Item._ENERGY?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .energy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .energy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.itemID.isEmpty {
      try visitor.visitSingularStringField(value: self.itemID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.chance.isEmpty {
      try visitor.visitSingularStringField(value: self.chance, fieldNumber: 4)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    switch self.payload {
    case .nft?: try {
      guard case .nft(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .icon?: try {
      guard case .icon(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .energy?: try {
      guard case .energy(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _EnergyRewardReceipt._Item, rhs: _EnergyRewardReceipt._Item) -> Bool {
    if lhs.itemID != rhs.itemID {return false}
    if lhs.name != rhs.name {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.chance != rhs.chance {return false}
    if lhs.type != rhs.type {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _EnergyRewardReceipt._Item._ItemType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "_ITEMTYPE_UNKNOWN"),
    1: .same(proto: "_ITEMTYPE_ICON"),
    2: .same(proto: "_ITEMTYPE_ENERGY"),
    3: .same(proto: "_ITEMTYPE_NFT"),
  ]
}

extension _EnergyRewardReceipt._Item._NFT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _EnergyRewardReceipt._Item.protoMessageName + "._NFT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "rarity"),
    3: .standard(proto: "token_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.rarity) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.tokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if self.rarity != .unknown {
      try visitor.visitSingularEnumField(value: self.rarity, fieldNumber: 2)
    }
    if self.tokenID != 0 {
      try visitor.visitSingularInt64Field(value: self.tokenID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _EnergyRewardReceipt._Item._NFT, rhs: _EnergyRewardReceipt._Item._NFT) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.rarity != rhs.rarity {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _EnergyRewardReceipt._Item._NFT._Rarity: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "_RARITY_UNKNOWN"),
    1: .same(proto: "_RARITY_COMMON"),
    2: .same(proto: "_RARITY_UNCOMMON"),
    3: .same(proto: "_RARITY_RARE"),
    4: .same(proto: "_RARITY_EPIC"),
    5: .same(proto: "_RARITY_LEGENDARY"),
    6: .same(proto: "_RARITY_EXCLUSIVE"),
  ]
}

extension _EnergyRewardReceipt._Item._ICON: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _EnergyRewardReceipt._Item.protoMessageName + "._ICON"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != .iconUnknown {
      try visitor.visitSingularEnumField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _EnergyRewardReceipt._Item._ICON, rhs: _EnergyRewardReceipt._Item._ICON) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _EnergyRewardReceipt._Item._ICON._IconID: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "_ICON_UNKNOWN"),
    1: .same(proto: "_ICON_ENERGY"),
  ]
}

extension _EnergyRewardReceipt._Item._ENERGY: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _EnergyRewardReceipt._Item.protoMessageName + "._ENERGY"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "amount"),
    3: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if self.size != .unknown {
      try visitor.visitSingularEnumField(value: self.size, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: _EnergyRewardReceipt._Item._ENERGY, rhs: _EnergyRewardReceipt._Item._ENERGY) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension _EnergyRewardReceipt._Item._ENERGY._Size: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "_SIZE_UNKNOWN"),
    1: .same(proto: "_SIZE_SMALL"),
    2: .same(proto: "_SIZE_MEDIUM"),
    3: .same(proto: "_SIZE_LARGE"),
  ]
}
